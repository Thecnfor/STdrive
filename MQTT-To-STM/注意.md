# MQTT-To-STM 操作手册

本库提供了一个基于 STM32 和 ESP8266 AT 指令的轻量级 MQTT 客户端实现。它旨在简化 MQTT 连接、发布和订阅过程，支持自动重连和心跳管理。

## 1. 快速开始

### 1.1 硬件连接
确保你的 ESP8266 模块已正确连接到 STM32 的串口（UART）。
*   **TX (ESP8266)** -> **RX (STM32)**
*   **RX (ESP8266)** -> **TX (STM32)**
*   **VCC/GND** -> **3.3V/GND**

### 1.2 软件配置 (`conn.h`)

在使用前，请打开 `conn.h` 并根据你的实际环境修改以下配置：

```c
/* ==========================================
 * 用户配置区域
 * ========================================== */
// 1. 串口配置
#define MQTT_UART_HANDLE &huart1     /* ESP8266 连接的串口句柄 */
#define MQTT_LOG_UART_HANDLE &huart2 /* 调试日志输出串口（可选） */

// 2. WiFi 配置
#define WIFI_SSID "Your_WiFi_SSID"
#define WIFI_PASSWORD "Your_WiFi_Password"

// 3. MQTT Broker 配置
#define MQTT_BROKER "broker.emqx.io" /* MQTT 服务器地址 */
#define MQTT_PORT 1883               /* MQTT 端口 */
#define MQTT_CLIENT_ID "stm32_client"
#define MQTT_KEEPALIVE 60

// 4. 资源配置
#define MAX_SUBSCRIPTIONS 10         /* 最大允许订阅的主题数量 */
```

## 2. 核心功能与使用

### 2.1 初始化与主循环

在 `main.c` 中，你需要调用 `MQTT_Start()` 进行初始化，并在主循环中定期调用 `MQTT_Service()` 以处理后台任务（如接收消息、心跳保活）。

```c
/* main.c 示例 */
#include "conn.h"

/* 1. 定义回调函数 */
void OnLedControl(const char *topic, const char *payload) {
    // 处理 LED 控制逻辑
}

/* 2. 定义订阅列表 (哨兵模式) */
MQTT_SubscribeInfo my_subs[] = {
    {"cmd/led", OnLedControl},
    {NULL, NULL}
};

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_USART1_UART_Init();
    // ... 其他初始化 ...

    // 3. 注册订阅列表 (只需一次)
    MQTT_SetSubscriptions(my_subs);

    // 4. 启动 MQTT
    MQTT_Start();

    while (1) {
        // 5. 后台服务 (自动处理连接、重连、订阅恢复)
        MQTT_Service();

        // 简单的状态检查与发布
        if (MQTT_IsConnected()) {
            static uint32_t last_pub = 0;
            if (HAL_GetTick() - last_pub > 5000) {
                MQTT_Publish("device/status", "online");
                last_pub = HAL_GetTick();
            }
        }
        
        HAL_Delay(50);
    }
}
```

### 2.2 消息订阅与回调

本库支持两种消息处理方式：**特定主题回调**（推荐）和**全局回调**。

#### 方式一：批量设置订阅（推荐）

使用 `MQTT_SetSubscriptions` 可以一次性配置所有订阅。系统会自动处理订阅请求，并在收到消息时调用对应的回调函数。

**注意**：订阅列表必须以 `{NULL, NULL}` 结尾（哨兵模式）。

```c
// 定义回调函数
void OnLedControl(const char *topic, const char *payload) {
    if (strcmp(payload, "ON") == 0) {
        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
    } else {
        HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
    }
}

void OnMotorControl(const char *topic, const char *payload) {
    // 处理电机控制逻辑
}

// 定义订阅表 (必须以 NULL 结尾)
MQTT_SubscribeInfo my_subs[] = {
    {"cmd/led", OnLedControl},
    {"cmd/motor", OnMotorControl},
    {NULL, NULL} // <--- 关键：结束标志
};

// 在 MQTT_Start() 之后调用
MQTT_SetSubscriptions(my_subs);
```

#### 方式二：手动订阅

你也可以手动调用接口进行订阅。

```c
// 仅订阅，不绑定特定回调（需配合全局回调使用）
MQTT_Subscribe("some/topic");

// 订阅并绑定回调
MQTT_SubscribeCallback("some/topic", OnMyCallback);
```

#### 方式三：全局回调

如果你希望在一个函数中处理所有未被特定回调捕获的消息：

```c
void GlobalMessageHandler(const char *topic, const char *payload) {
    printf("收到未知主题消息: %s -> %s\n", topic, payload);
}

// 设置全局回调
MQTT_SetMessageHandler(GlobalMessageHandler);
```

### 2.3 发布消息

```c
bool success = MQTT_Publish("topic/name", "Hello World");
if (!success) {
    // 发送失败处理
}
```

## 3. 高级特性

*   **自动重连**: `MQTT_Service()` 内部集成了状态机，当 WiFi 或 TCP 断开时，会自动尝试重连，无需用户干预。
*   **RTOS 支持**: 你可以将 `MQTT_Service()` 放在一个独立的 FreeRTOS 任务中运行。
*   **定时器驱动**: 如果定义了 `MQTT_TIM_HANDLE`，可以由定时器中断驱动服务例程，实现完全后台化的运行。

## 4. 常见问题

*   **Q: 订阅数量限制？**
    *   A: 修改 `conn.h` 中的 `MAX_SUBSCRIPTIONS` 宏来调整最大支持的订阅数。
*   **Q: 为什么订阅没生效？**
    *   A: 请检查 `MQTT_SetSubscriptions` 传入的数组是否以 `{NULL, NULL}` 结尾。
*   **Q: 接收缓冲区溢出？**
    *   A: 默认缓冲区为 512 字节。如需传输大数据，请增大 `conn.h` 中的 `RX_BUFFER_SIZE`。
